<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>问答系统</title>
    <link rel="stylesheet" href="/static/css/style.css"/>
    <!-- 新增：删除按钮样式（尽量与现有样式兼容） -->
    <style>
        /* filepath: c:\Users\w3113\Desktop\teacher-agent\templates\index.html (style additions) */
        .thread-item, .doc-item {
            position: relative;
            padding-right: 60px; /* 给删除按钮留出位置 */
        }
        .item-delete-btn {
            position: absolute;
            right: 8px;
            top: 8px;
            display: none;
            background: #e74c3c;
            color: #fff;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        .thread-item:hover .item-delete-btn,
        .doc-item:hover .item-delete-btn {
            display: inline-block;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
</head>
<body>
    <div class="container">
        <nav>
            <span>已登录：{{ user }}</span>
            <a href="/logout" style="margin-left:10px;">退出登录</a>
        </nav>

        <h1>问答系统</h1>

        <!-- 三列布局：left / center(segments) / right(chat) -->
        <div class="layout three-col">
            <div class="left">
                <div style="margin-bottom:8px;">
                    <button onclick="createThreadPrompt()">新建会话</button>
                    <button onclick="loadThreads()">刷新会话</button>
                </div>

                <div>
                    <h4>会话</h4>
                    <div id="threadList">加载中...</div>
                </div>

                <div style="margin-top:12px;">
                    <h4>已上传文件</h4>
                    <div id="docList">加载中...</div>
                    <div style="margin-top:6px;">
                        <button onclick="loadDocuments()">刷新文件列表</button>
                    </div>
                </div>
            </div>

            <div class="center">
                <h4>文档分段预览</h4>
                <div id="segments">请选择左侧文件查看分段预览</div>
            </div>

            <div class="main">
                <div class="chat-header">
                    <strong>当前会话：</strong><span id="currentThread">无（新建或选择会话）</span>
                </div>

                <div id="messages" class="chat-window">请选择或新建会话以查看消息</div>

                <div class="chat-input">
                    <textarea id="question" placeholder="请输入你的问题..." style="height:72px"></textarea>
                    <div class="chat-actions">
                        <button onclick="askQuestion()">提交问题</button>
                    </div>
                </div>

                <div style="margin-top:12px">
                    <h4>上传文档</h4>
                    <input type="file" id="fileInput" accept=".pdf,.docx">
                    <button onclick="uploadFile()">上传文档</button>
                    <div id="uploadResponse" class="response" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedThreadId = null;
        let selectedThreadTitle = '';
        let selectedDocumentId = null;
        let threadResponses = {};

        // 新增：每个会话的草稿存储（页面内存）
        let drafts = {};
        function draftKeyFor(id) { return id ? `t_${id}` : '__new__'; }

        document.addEventListener('DOMContentLoaded', () => {
            const q = document.getElementById('question');
            q.value = drafts['__new__'] || '';
            // 输入时持续保存当前会话草稿
            q.addEventListener('input', (e) => {
                drafts[draftKeyFor(selectedThreadId)] = e.target.value;
            });
        });

        function loadThreads(){
            const list = document.getElementById('threadList');
            list.textContent = '加载中...';
            fetch('/threads')
                .then(r => r.json())
                .then(j => {
                    list.innerHTML = '';
                    if (!j.items || j.items.length === 0) {
                        list.textContent = '无会话，点击“新建会话”开始。';
                        return;
                    }
                    j.items.forEach(it => {
                        const div = document.createElement('div');
                        div.className = 'thread-item' + (selectedThreadId===it.id ? ' active' : '');
                        div.innerHTML = `<div><strong>#${it.id}</strong> ${escapeHtml(it.title || '(无标题)')}</div><div style="font-size:12px;color:#666">${it.created_at}</div>`;
                        div.onclick = () => selectThread(it.id, it.title || '');
                        // 添加删除按钮（悬停时显示）
                        const del = document.createElement('button');
                        del.className = 'item-delete-btn';
                        del.textContent = '删除';
                        del.title = '删除会话';
                        del.onclick = (e) => {
                            e.stopPropagation();
                            deleteThread(it.id, div);
                        };
                        div.appendChild(del);
                        list.appendChild(div);
                    });
                })
                .catch(e => { document.getElementById('threadList').textContent = '加载失败'; console.error(e); });
        }

        function createThreadPrompt(){
            const title = prompt('输入会话标题（可空）：', '');
            fetch('/threads', {
                method:'POST',
                headers:{'Content-Type':'application/json','Accept':'application/json'},
                body: JSON.stringify({title: title || ''})
            })
            .then(r => r.json())
            .then(j => {
                if (j.thread_id) {
                    selectedThreadId = j.thread_id;
                    selectedThreadTitle = title || '';
                    document.getElementById('currentThread').textContent = `#${selectedThreadId} ${selectedThreadTitle}`;
                    loadThreads();
                    // 恢复该会话的草稿（如果之前有）
                    document.getElementById('question').value = drafts[draftKeyFor(selectedThreadId)] || '';
                    loadMessages(selectedThreadId);
                } else {
                    alert('创建失败');
                }
            })
            .catch(e => { alert('请求失败'); console.error(e); });
        }

        // 新增：选择并展示文档分段
        async function selectDocument(docId){
            selectedDocumentId = docId;
            // 更新左侧高亮
            Array.from(document.getElementsByClassName('doc-item')).forEach(el=>{
                if (el.dataset && String(el.dataset.docId) === String(docId)) el.classList.add('active');
                else el.classList.remove('active');
            });
            const segDiv = document.getElementById('segments');
            if (!segDiv) return;
            segDiv.textContent = '加载分段中...';
            try {
                const resp = await fetch(`/my_documents/${encodeURIComponent(docId)}/segments`);
                if (!resp.ok) throw new Error('网络错误');
                const j = await resp.json();
                if (j.error) {
                    segDiv.textContent = `错误: ${j.error}`;
                    return;
                }
                const segs = j.segments || [];
                if (segs.length === 0) {
                    segDiv.textContent = '该文档无分段';
                    return;
                }
                segDiv.innerHTML = '';
                segs.forEach(s => {
                    const item = document.createElement('div');
                    item.className = 'segment';
                    // 简单渲染分段索引、向量 id 与预览文本（已做 HTML 转义）
                    item.innerHTML = `<div style="font-size:12px;color:#666">#${s.index} · vec:${s.vector_id}</div><div>${escapeHtml(s.preview)}</div>`;
                    segDiv.appendChild(item);
                });
            } catch (e) {
                console.error(e);
                segDiv.textContent = '加载分段失败';
            }
        }

        function selectThread(id, title){
            // 在切换前保存当前输入（已在 input 事件里保存，但这里再确保）
            drafts[draftKeyFor(selectedThreadId)] = document.getElementById('question').value;
            selectedThreadId = id;
            selectedThreadTitle = title || '';
            selectedDocumentId = null;
            document.getElementById('currentThread').textContent = `#${id} ${selectedThreadTitle}`;
            Array.from(document.getElementsByClassName('thread-item')).forEach(el=>el.classList.remove('active'));
            loadThreads();
            // 切换时恢复对应草稿
            document.getElementById('question').value = drafts[draftKeyFor(selectedThreadId)] || '';
            loadMessages(id);
            // 不再使用单独的实时输出面板，清理旧显示（先判空以避免 null 访问）
            const respDiv = document.getElementById('response');
            if (respDiv) {
                respDiv.style.display = 'none';
                respDiv.textContent = '';
            }
        }

        function loadMessages(threadId){
            const msgDiv = document.getElementById('messages');
            msgDiv.textContent = '加载消息中...';
            fetch(`/threads/${encodeURIComponent(threadId)}/messages`)
                .then(r => {
                    if (!r.ok) throw new Error('网络错误');
                    return r.json();
                })
                .then(j => {
                    if (j.error) {
                        msgDiv.textContent = `错误: ${j.error}`;
                        return;
                    }
                    const items = j.messages || [];
                    if (items.length === 0) {
                        msgDiv.innerHTML = '该会话暂无消息';
                        return;
                    }
                    msgDiv.innerHTML = '';
                    items.forEach(m => {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'msg ' + (m.role === 'user' ? 'user' : 'assistant');
                        const meta = document.createElement('div');
                        meta.className = 'msg-meta';
                        meta.textContent = `${m.role} · ${m.created_at || ''}`;
                        const body = document.createElement('div');
                        body.className = 'msg-body';
                        const content = m.content || '';

                        if (m.role === 'assistant') {
                            try {
                                const rawHtml = marked.parse(content);
                                const safe = DOMPurify.sanitize(rawHtml);
                                body.innerHTML = safe;
                                body.querySelectorAll('pre code').forEach((block) => {
                                    try { hljs.highlightElement(block); } catch (e) {}
                                });
                            } catch (e) {
                                body.textContent = content;
                            }
                        } else {
                            // user 消息以纯文本展示，避免 HTML 注入
                            body.textContent = content;
                        }

                        wrapper.appendChild(meta);
                        wrapper.appendChild(body);
                        msgDiv.appendChild(wrapper);
                    });
                    msgDiv.scrollTop = msgDiv.scrollHeight;
                })
                .catch(err => {
                    console.error(err);
                    msgDiv.textContent = '加载消息失败';
                });
        }

        async function askQuestion(){
            const qElem = document.getElementById('question');
            const question = qElem.value.trim();

            if (!question) { alert('请输入问题'); return; }

            try {
                // 如果没有选中会话，先创建一个会话
                if (!selectedThreadId) {
                    const resp = await fetch('/threads', {
                        method: 'POST',
                        headers: {'Content-Type':'application/json','Accept':'application/json'},
                        body: JSON.stringify({title: ''})
                    });
                    const j = await resp.json();
                    if (!j.thread_id) {
                        alert('创建会话失败');
                        return;
                    }
                    const oldDraft = drafts['__new__'] || '';
                    selectedThreadId = j.thread_id;
                    selectedThreadTitle = '';
                    if (oldDraft) drafts[draftKeyFor(selectedThreadId)] = oldDraft;
                    delete drafts['__new__'];
                    document.getElementById('currentThread').textContent = `#${selectedThreadId} ${selectedThreadTitle}`;
                    loadThreads();
                }

                // 本次流绑定的 thread id（固定）
                const streamThreadId = selectedThreadId;

                // 立即在当前消息窗口追加 user 消息和一个空的 assistant 占位（用于流式更新）
                const msgDiv = document.getElementById('messages');

                // append user message
                const userWrap = document.createElement('div');
                userWrap.className = 'msg user';
                const userMeta = document.createElement('div');
                userMeta.className = 'msg-meta';
                userMeta.textContent = `user · ${new Date().toLocaleString()}`;
                const userBody = document.createElement('div');
                userBody.className = 'msg-body';
                userBody.textContent = question;
                userWrap.appendChild(userMeta);
                userWrap.appendChild(userBody);
                msgDiv.appendChild(userWrap);

                // append assistant placeholder
                const assistantWrap = document.createElement('div');
                assistantWrap.className = 'msg assistant';
                const assistantMeta = document.createElement('div');
                assistantMeta.className = 'msg-meta';
                assistantMeta.textContent = `assistant · 正在回答...`;
                const assistantBody = document.createElement('div');
                assistantBody.className = 'msg-body';
                assistantBody.innerHTML = ''; // will update with markdown-rendered HTML
                assistantWrap.appendChild(assistantMeta);
                assistantWrap.appendChild(assistantBody);
                msgDiv.appendChild(assistantWrap);
                msgDiv.scrollTop = msgDiv.scrollHeight;

                // 发起 EventSource 流
                const url = `/ask?question=${encodeURIComponent(question)}&thread_id=${encodeURIComponent(streamThreadId)}`;
                const es = new EventSource(url);
                let full = '';

                es.onmessage = function(event){
                    if (event.data === '[DONE]') {
                        es.close();
                        // 清空草稿
                        delete drafts[draftKeyFor(streamThreadId)];
                        qElem.value = '';
                        loadThreads();
                        // 在流结束后，用后端最新消息刷新以保证一致性
                        if (selectedThreadId === streamThreadId) {
                            // 把 meta 更新成结束时间
                            assistantMeta.textContent = `assistant · ${new Date().toLocaleString()}`;
                            // 延迟刷新消息列表以避免闪烁（可根据需要移除）
                            setTimeout(()=>loadMessages(selectedThreadId), 300);
                        }
                        return;
                    }
                    try {
                        const data = JSON.parse(event.data);
                        if (data.error) {
                            assistantBody.textContent = `错误: ${String(data.error)}`;
                            es.close();
                            return;
                        }
                        if (data.content) {
                            full += data.content;
                            // 渲染 Markdown（实时）
                            try {
                                const rawHtml = marked.parse(full);
                                const safe = DOMPurify.sanitize(rawHtml);
                                assistantBody.innerHTML = safe;
                                // highlight code blocks
                                assistantBody.querySelectorAll('pre code').forEach((block) => {
                                    try { hljs.highlightElement(block); } catch(e) {}
                                });
                                msgDiv.scrollTop = msgDiv.scrollHeight;
                            } catch (e) {
                                assistantBody.textContent = full;
                                msgDiv.scrollTop = msgDiv.scrollHeight;
                            }
                        }
                    } catch (e) {
                        console.error('解析 SSE 数据失败', e);
                    }
                };

                es.onerror = function(){
                    es.close();
                    assistantBody.textContent = '连接出错，请重试';
                };

            } catch (e) {
                console.error(e);
                alert('请求失败');
            }
        }

        // ----------------- 文档相关 -----------------
        function loadDocuments(){
            const div = document.getElementById('docList');
            div.textContent = '加载中...';
            fetch('/my_documents')
                .then(r => r.json())
                .then(j => {
                    div.innerHTML = '';
                    if (!j.items || j.items.length === 0) {
                        div.textContent = '未上传文件';
                        return;
                    }
                    j.items.forEach(d => {
                        const el = document.createElement('div');
                        el.className = 'doc-item';
                        // 新增：标记 DOM 节点的文档 id，便于选中和高亮
                        el.dataset.docId = d.id;
                        el.innerHTML = `<div><strong>#${d.id}</strong> ${escapeHtml(d.filename)}</div><div style="font-size:12px;color:#666">分段: ${d.segment_count} · ${d.stored_at}</div>`;
                        el.onclick = () => selectDocument(d.id);
                        // 添加删除按钮（悬停时显示）
                        const del = document.createElement('button');
                        del.className = 'item-delete-btn';
                        del.textContent = '删除';
                        del.title = '删除文件';
                        del.onclick = (e) => {
                            e.stopPropagation();
                            deleteDocument(d.id, el);
                        };
                        el.appendChild(del);
                        div.appendChild(el);
                    });
                })
                .catch(e => { div.textContent = '加载失败'; console.error(e); });
        }

        // 新增：删除会话（调用 DELETE /threads/<id>）
        async function deleteThread(threadId, domNode){
            if (!confirm(`确认删除会话 #${threadId}？此操作不可恢复。`)) return;
            try {
                const resp = await fetch(`/threads/${encodeURIComponent(threadId)}`, { method: 'DELETE' });
                const j = await resp.json();
                if (resp.ok && j.success) {
                    // 从界面移除
                    if (domNode && domNode.parentNode) domNode.parentNode.removeChild(domNode);
                    // 如果当前正在查看该会话，清理视图
                    if (selectedThreadId === threadId) {
                        selectedThreadId = null;
                        selectedThreadTitle = '';
                        document.getElementById('currentThread').textContent = '无（新建或选择会话）';
                        document.getElementById('messages').innerHTML = '请选择或新建会话以查看消息';
                        document.getElementById('question').value = drafts[draftKeyFor(selectedThreadId)] || '';
                    }
                    // 可选：刷新会话列表
                    loadThreads();
                } else {
                    alert('删除失败：' + (j.error || JSON.stringify(j)));
                }
            } catch (e) {
                console.error(e);
                alert('删除请求失败');
            }
        }

        // 新增：删除文档（调用 DELETE /my_documents/<id>）
        async function deleteDocument(docId, domNode){
            if (!confirm(`确认删除文件 #${docId}？此操作会移除数据库记录并尝试删除磁盘文件。`)) return;
            try {
                const resp = await fetch(`/my_documents/${encodeURIComponent(docId)}`, { method: 'DELETE' });
                const j = await resp.json();
                if (resp.ok && j.success) {
                    if (domNode && domNode.parentNode) domNode.parentNode.removeChild(domNode);
                    if (selectedDocumentId === docId) {
                        selectedDocumentId = null;
                        document.getElementById('segments').innerHTML = '请选择左侧文件查看分段预览';
                    }
                    // 可选：刷新文件列表与分段视图
                    loadDocuments();
                    if (selectedDocumentId) selectDocument(selectedDocumentId);
                } else {
                    alert('删除失败：' + (j.error || JSON.stringify(j)));
                }
            } catch (e) {
                console.error(e);
                alert('删除请求失败');
            }
        }

        function clearConversation(){
            const resp = document.getElementById('response');
            if (resp) {
                resp.textContent = '';
                resp.style.display = 'none';
            }
        }

        function escapeHtml(s){ return String(s || '').replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]); }); }

        // 初始加载
        loadThreads();
        loadDocuments();
    </script>
</body>
</html>